\section{Указатели}

\begin{definition}
  \textit{Указатель} -- это объект, содержащий адрес объекта или функции, либо выражение, обозначающее адрес объекта или функции.
\end{definition}

\subsection{Указатели в языке Си}

Объявляется как обычная переменная, но перед именем указывается знак ``астерикс'' (\texttt{*}). Пример: \texttt{int *p};

\subsubsection{Разновидности указателей}

\begin{itemize}
  \item Типизированный указатель.
  \item Бестиповый указатель (\texttt{void *p}).
  \item Указатель на функцию.
\end{itemize}

\subsubsection{Зачем нужны указатели?}

\begin{itemize}
  \item Передача изменяемых параметров в функцию.
  \item Передача объёмных параметров; считаем параметр объёмным, если он занимает больше памяти, чем \texttt{double}.
  \item Динамическое выделение памяти.
  \item Реализация ссылочных типов данных.
\end{itemize}

\subsubsection{Операции с указателями}

\textit{Операция получения адреса} -- возвращает адрес переменной в памяти. Обозначается как знак \texttt{\&} перед именем переменной. Пример:
\begin{minted}{c}
int a = 5;
int *p = &a;
\end{minted}

\textit{Операция разыменования} -- возвращает значение переменной по адрес. Обозначается как знак \texttt{*} перед именем переменной. Пример:
\begin{minted}{c}
int a = 5;
int *p = &a;
int b = *p; // 5
\end{minted}

\begin{note}
  Типичная ошибка: знак \texttt{*} принадлежит ближайшему имени переменной. То есть:
  \begin{minted}{c}
int *a, b;  // a - указатель, b - целочисленная переменная
int a = 5, *p = &a; // можно сделать так
  \end{minted}
\end{note}

Размер указателя одинаковый в рамках машины.

Операции \texttt{*} и \texttt{\&} -- взаимно обратные. То есть выражение \texttt{\&*a} превращается в просто \texttt{a}.

\subsubsection{Инициализация указателей}

Указатель может инициализироваться:
\begin{itemize}
  \item адресом переменной того же типа;
  \item значением указателя того же типа;
  \item значением \texttt{NULL};
\end{itemize}

\subsubsection{Указатели и \texttt{const}}

Следует различать два способа использования ключевого слова \texttt{const} с указателями.

\begin{enumerate}
  \item Указатель на константу: \texttt{const int *p}. Нельзя изменить значение, на которое указывает указатель.
  \item Константный указатель: \texttt{int *const p}. Нельзя изменить адрес переменной, на которую ссылается указатель.
\end{enumerate}

Можно комбинировать два вида использования \texttt{const} и получить \textit{константный указатель на константу}, который совмещает свойства двух предыдущих. 

\subsection{Указатели и массивы}

Результат выражения, состоящего из имени массива, представляет собой адрес области памяти, выделенной под этот массив (англ. \textit{``array decay to pointer''})

\begin{minted}{c}
int a[10], *pa;
pa = a;
pa = &a[0];
\end{minted}

\subsubsection{Исключения}

\begin{enumerate}
  \item \texttt{sizeof} для массива возвращает его размер, а для указателя -- размер переменой, содержащей адрес.
  \item При взятии адрес от массива, вернётся значение типа \textit{указатель на масссив}, который будет численно равен адресу массива.
  \item Строковый литерал-инициализатор массива \texttt{char[]}.
\end{enumerate}

\subsubsection{Различия указателя и массива}

\begin{itemize}
  \item Массиву нельзя присвоить другой адрес.
  \item Под переменные выделяется разное количество памяти.
\end{itemize}

\subsubsection{Передача массива в функцию}

Любое объявление параметра, похожее на массив, трактуется компилятором как указатель.
Это значит, что следующий код абсолютно валиден:
\begin{minted}{c}
void foo(int a[10])
{ ... }

int arr[25] = { ... };
int a = 5, *pa = &a;
foo(arr);
foo(pa);
\end{minted}

Из этого следует, что функция \textit{не может узнать размер массива через \texttt{sizeof}}.

\subsubsection{Тип \texttt{size\_t}}

\texttt{size\_t} -- беззнаковый целый тип, предназначенный для представления размера любого объекта в памяти. Размер типа определяется относительно возможностей аппаратной платформы. Тип определен в заголовочном файле \texttt{stddef.h}.

Максимальный размер \texttt{size\_t} указан в константе \texttt{SIZE\_MAX}, определённой в \texttt{stdint.h}

\subsubsection{Сложение указателя с числом}

Запись вида:
\begin{minted}{c}
  int a, *pa = &a;
  int pb = pa + n;
\end{minted}
.
Обозначает операцию: \textit{адрес \texttt{pb} равен адресу \texttt{pa} плюс n размеров переменной-типа указателя}.

То есть можно записать как:
\begin{minted}{c}
int arr[10] = { ... };
arr + 2;     // arr[2]
\end{minted}

\subsubsection{Операция индексации}

Компилятор заменяет оператор индексации \texttt{arr[i]} на выражение вида \texttt{*(arr + i)}

\subsubsection{Сравнение указателей}

Указатели можно сравнивать:
\begin{itemize}
  \item одного типа;
  \item с \texttt{NULL}.
\end{itemize}

\subsubsection{Разность указателей}

Указатели можно вычитать. Разница будет представлена типом \texttt{ptrdiff\_t}. Данный тип определён в заголовочном файле \texttt{stddef.h}

\begin{minted}{c}
int arr[];
ptrdiff_t pd = arr[0] - arr[2];  // -2
\end{minted}

