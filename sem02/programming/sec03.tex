\section{Функции}

\subsection{Подпрограмма}

\begin{definition}
  \textit{Подпрограмма} -- именованная часть программы, содержащая описание определённого набора действий. Подпрограмма может быть многократно вызвана из разных частей программы.
\end{definition}

Преимущества использования подпрограмм:
\begin{itemize}
  \item Уменьшение сложности программирования за счёт декомпозиции задачи.
  \item Уменьшение дублирования код.
  \item Возможность повторного использования кода.
  \item Сокрытие деталей реализации от пользователей подпрограммы.
\end{itemize}

\subsubsection{Виды подпрограмм}

\begin{definition}
  \textit{Функция} -- это подпрограмма специального вида, которая всегда должна возвращать результат. Вызов функции является выражением.
\end{definition}

\begin{definition}
  \textit{Процедура} -- это независимая именованная часть программы, которую после однократного описания можно многократно вызвать по имени из последующих частей программы для выполнения определенных действий.
\end{definition}

\subsubsection{Структура подпрограммы}

Любая подпрограмма состоит из двух частей: \textit{заголовка} и \textit{тела подпрограммы}.  
Заголовок описывает информацию, необходимую для вызова подпрограммы. Тело подпрограммы -- набор операторов.

\subsubsection{Вызов подпрограммы}

Вызов подпрограммы выполняется с помощью команды вызова, включающей в себя имя подпрограммы, за которым следуют параметры. 

Чтобы отличать параметры подпрограммы, описанные в её заголовке и теле, от параметров, указываемых при вызове подпрограммы, используются \textit{формальные} и \textit{фактические} параметры. Формальные параметры указываются при описании подпрограммы, а фактические – непосредственно при её вызове. Фактические параметры часто называют \textit{аргументами}.

\subsection{Передача параметров}

Параметры могут передаваться \textit{по значению} и \textit{по ссылке}.

При передаче параметра по значению значение аргумента используется для инициализации формального параметра. Таким образом, изменение формального параметра внутри подпрограммы \textit{не влияет на вызывающий код}.

При передаче параметра по ссылке, подпрограмма получает доступ к ячейке памяти, в которой находится аргумент. Изменение формального параметра в таком случае повлияет на вызывающий код.

\subsection{Функции в языке Си}

\subsubsection{Возвращаемое значениe}

\begin{itemize}
  \item Функция может вернуть значение любого типа кроме массива.
  \item Если функция ничего не возвращает, то в качестве возвращаемого значения следует указать \texttt{void}.
  \item Для возврата значения используется оператор \texttt{return}.
\end{itemize}

\subsubsection{Параметры функции}

\begin{itemize}
  \item Любая функция может принимать параметры.
  \item Перед именем каждого параметра указывается его тип. Тип указывается перед каждым параметром, даже если несколько параметров имеют один и тот же тип!
  \item Описания параметров в списке разделяются запятыми.
  \item Если у функции нет параметров, вместо списка параметров указывается ключевое слово \texttt{void}.
\end{itemize}

\subsubsection{Тело функции}

\begin{itemize}
  \item У каждой функции есть исполнимая часть, которая называется \textit{телом функции} и заключена в фигурные скобки.
  \item Тело функции может содержать как описания переменных, так и операторы. Переменные, описанные в теле функции, ``принадлежат'' только этой функции и не могут быть ни получены, ни изменены другой функцией.
  \item Тело функции не может содержать в себе определения других функций.
\end{itemize}

Оператор \textit{return} прерывает выполнение функции и возвращает вычисленное значение и управление в ту часть программы, из которой эта функция была вызвана. Его можно использовать в функциях, которые ничего не возвращают.

\subsubsection{Объявление функции}

Объявление функции предоставляет компилятору всю информацию, необходимую для вызова функции: количество и типы параметров, их последовательность, тип возвращаемого значения.

Объявление функции состоит из заголовка функции

Пример объявления функции:
\begin{minted}{c}
double average(double a, double b)
\end{minted}

\subsubsection{Объявление и определение}

Объявление (\textit{declaration}) – это инструкция компилятору, как использовать указанное имя (описывает свойства переменной или функции). Объявлений одного и того же имени может быть сколько угодно, главное чтобы они все были согласованы (т.е. одинаковы).

Определение (\textit{definition}) осуществляет привязку имени к сущности (к памяти для данных или к коду для функций), т.е. специфицирует код или данные, которые стоят за этим именем. В языке Си существует правило единственного определения. Это означает, что определение может быть только одно.

Пример:

\begin{minted}{c}
// Объявление
double average(double a, double b);

...

// Объявление
double average(double a, double b)
{   // Определение
  return (a + b) / 2
}
\end{minted}

\subsubsection{Функции без параметров}

\texttt{void foo(void)} -- функция, которая точно не принимает ни одного параметра.

\texttt{void foo()} -- функция может принимать любой (в том числе и нулевое) количество параметров.

\subsubsection{Чистые функции}

\begin{definition}
  \textit{Чистой функцией} называется функция, которая удовлетворяет следующим условиями:
  \begin{itemize}
    \item является детерминированной;
    \item не обладает побочными эффектами.
  \end{itemize}
\end{definition}

\begin{definition}
  Функция называется \texttt{детерминированной}, если для одного и того же набора входных данных она возвращает один и тот же результат.
\end{definition}

\begin{definition}
  Функции с побочными эффектами -- это функции, которые в процессе выполнения своих вычислений могут модифицировать значения глобальных переменных, осуществлять операции ввода/вывода.
\end{definition}

\subsubsection{Вызов функции}

\begin{enumerate}
  \item Выделяется память.
  \item Создаются локальные переменные и параметры.
  \item Параметрам присваиваются переданные в функцию значения.
  \item Инициализация локальных переменных.
  \item Выполнение тела функции.
  \item Значние возвращается из функции.
  \item Освобождается память.
\end{enumerate}

\subsubsection{Выводы}

\begin{itemize}
  \item Параметры-переменные и локальные переменные отличаются только одним: параметрам-переменным автоматически присваиваются начальные значения, равные значениям в точке вызова функции.
  \item В функции изменяется параметр-переменная, а не переменная, переданная в качестве аргумента. Функция ``забывает'' о переменной-аргументе сразу же после инициализации параметра-переменной.
  \item Имена параметров-переменных могут совпадать с именами переменных, передаваемых в качестве аргументов.
\end{itemize}

\subsection{Рекурсия}

\begin{definition}
  \textit{Рекурсией} называется являение, когда функция вызывает саму себя.
\end{definition}

Вычисление факториала как пример рекурсии:

\begin{minted}{c}
int fact(int n)
{
  if (n == 0)
    return 1;
  return n * fact(n - 1);
}
\end{minted}

\subsubsection{Преимущества и недостатки использования рекурсии}

Преимущества
\begin{itemize}
  \item Рекурсивная форма может быть структурно проще и нагляднее, в особенности, когда сам реализуемый алгоритм рекурсивен.
\end{itemize}

Недостатки
\begin{itemize}
  \item Рекурсивный вызов использует больше памяти, поскольку создает свой набор переменных.
  \item Рекурсия выполняется медленней, поскольку на каждый вызов функции требуется определенное время.
\end{itemize}

\subsubsection{Хвостовая рекурсия}

\begin{definition}
  \textit{Хвостовой рекурсией} называется частный случай рекурсии, при котором любой рекурсивный вызов является последней операцией перед возвратом из функции.
\end{definition}

Подобный вид рекурсии может быть легко заменён на итерацию путём формальной и гарантированно корректной перестройки кода функции. Оптимизация хвостовой рекурсии путём преобразования её в итерацию реализована во многих оптимизирующих компиляторах.

